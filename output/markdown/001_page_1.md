Copy

# 101.1. Determine and configure hardware settings

## **101.1 Determine and configure hardware settings**

\*\*Weight:\*\*2

\*\*Description: \*\*Candidates should be able to determine and configure fundamental system hardware.

**Key Knowledge Areas:**

* Tools and utilities to list various hardware information (e.g. lsusb, lspci, etc.)
* Tools and utilities to manipulate USB devices
* Conceptual understanding of sysfs, udev, dbus

**The following is a partial list of the used files, terms and utilities:**

* /sys/
* /proc/
* /dev/
* modprobe
* lsmod
* lspci
* lsusb

Linux treat every thing as a file. It includes programs , hardware and even processes which are running. These files are organized in directories and standardize for easier access and administration. Lets see how linux dealing with devices:

### /proc

The /proc is a virtual dicretory which contains a illusionary filesystem called procfs. It does not exist on a disk. Instead, the kernel creates it in memory. It is used to provide information about the system (originally about processes).

Some of the more important files and directories are :

**/proc/1:** A directory with information about process number 1. Each process has a directory below /proc with the name being its process identification number.

\*\*/proc/cpuinfo: \*\*Information about the processor, such as its type, make, model, and performance.

\*\*/proc/filesystems : \*\*Filesystems configured into the kernel.

\*\*/proc/interrupts: \*\*Shows which interrupts are in use, and how many of each there have been.

\*\*/proc/meminfo : \*\*Information about memory usage, both physical and swap.

The way /proc virtual directory organize processes get noticed by developers and they started to use /proc for both reading and writing information. So guess what, little by little /proc become a place which stored different kind of information. Processes information, current running Kernel information, hardware information, system information. Some one should do some thing to stop this messy place and that cause /sys introducing in kernel 2.5 .

### /sys

/sys it is a virtual directory with illusionary sysfs file system, which is created when system boots up and get vanished when system restarts or goes off.

sysfs introduced to specifically store system information and its components (mostly attached and installed hardware). An as it was planned for that its seems more organized and more standardize than procfs.

sysfs hasn't caused all the stuff move from /proc to /sys , they still exist in /proc but /sys gives us a better view of current data.

**Linux kernel modules** (LKMs) are pieces of code which can be loaded into the kernel much like a hot-swappable piece of hardware. they can be inserted into the kernel and activated without the system needing to be rebooted.

### udev

The kernel is the central part of operating system to address the hardware. And to make sure that the hardware is available for the kernel udev plays an important role.

udev is a replacement for the Device File System (DevFS) starting with the Linux 2.6 kernel series. udev plays role in Loading Kernel Module, Creating Device Files and making sure every thing is the order we need it to be. Lets see how it works:

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LqAGZBTzViD1dkOj2A0%252F-LqAG_WIhgliGcuNIR3k%252Fhw-udev.jpg%3Fgeneration%3D1569999716054769%26alt%3Dmedia&width=768&dpr=4&quality=100&sign=fac2f840&sv=2)

1. The linux kernel initiates the device loading and next sends out messages (uevents) to the udev daemon.
2. udev daemon catches the event and decide how to handle based on the attributes that it has received in the event. udev load required kernel module with necessary information using **modprobe**.

what is modprobe?

**modprobe** is an intelligent command for listing, inserting as well as removing modules from the kernel.( Will be explained )

3 . udev next reads its rules . udev allows us to ban devices based on their properties, like vendor ID and device ID, ... .

* Default rules are in /lib/udev/rules.d
* Custom rules are in /etc/udev/rules.d

Lets see it in action, we use and then attach a usb storage:

udev write device information to the /sys virtual directory. Also udev works as an Hardware Abstaraction Layer(HAL) and creates device file entries under /dev directory in a structured way.

What is HAL? In computers, a **hardware abstraction layer** (**HAL**) is a **layer** of programming that allows a computer OS to interact with a **hardware** device at a general or **abstract level** rather than at a detailed **hardware level**.

another example:

We have seen this information previously. Try `udevadm info --attribute-walk --name=/dev/sda` for your self. These device attributes can be used in udev rules.

### /dev

This directory contains the **device files** for every hardware device attached to the system.

> **Device files** are employed to provide the operating system and users an interface to the devices that they represent.

/dev exits from early beginning versions of linux and it was populated by devfs. (As we mentioned) devfs was a an **obsolete and no longer available.**

These days, it has been replaced by udev, a daemon that manages the contents of /dev in a temporary filesystem, \*\*(\*\*or by devtmpfs, which is a lightweight replacement for devfs that is used in some minimal systems).

Actually they are files and pointers to the under laying device hardware. Try`ls -l` to see that .

There are some common device names in .in linux World :

with the special thanks of udev (as a Hardware Abstraction Layer) and the names it provides.

#### /sys vs /dev

* The /sys filesystem (sysfs) contains files that provide information about devices: whether it's powered on, the vendor name and model, what bus the device is plugged into, etc. It's of interest to applications that manage devices.
* The /dev filesystem contains files that allow programs to access the devices themselves: write data to a serial port, read a hard disk, etc. It's of interest to applications that access devices.

A metaphor is that /sys provides access to the packaging, while /dev provides access to the content of the box.

The reason for /dev existing independently of /sys is partly historical: /dev dates back to the dawn of Unix, while /sys is a much more recent invention. If Linux was designed today with no historical background, /dev/sda might be /sys/block/sda/content.

**pesudo File Systems**

'Pseudo-' means false, pretend. So "pseudo-filesystem" means a filesystem that doesn't have actual files – rather, it has virtual entries that the filesystem itself makes up on the spot.

/dev, /proc and /sys are virtual "pseudo-filesystems" (not existing on harddisk, but only in RAM – so they do not consume any harddisk space and are completely created on boot).

### dbus

D-Bus is a message bus system, a simple way for applications to talk to one another. Beside all of dbus benefits it can read information form /dev folder and relate them with user desktop programs using signals. In fact dbus make a kind of middle layer which keeps programs a way from difficulties of dealing with /dev and /sys directories.

\*\*Notice : \*\*udev and dbus can work in all distributions because sysfs has made required information standardize.

From the administrative perspective there are some ls utilities ( lsusb, lspci , ... ) to show more information about the hardware which has been attached to our system. Lets take a quick look at them:

### lsusb

The lsusb command allows you to display information about USB buses and devices that are attached to them.

lsusb has some options:

We can also use the `-v` command-line option to display more verbose output:

`-t` tells lsusb to dump the physical USB device hierarchy as a tree. This overrides the v option.

`-V`or `--version` Print version information on standard output, then exit successfully.

try `usb-devices` , it will give us more detailed info.

### lscpu

lscpu reports information about the cpu and processing units. It does not have any further options or functionality.

### lshw

lshw is a general purpose utility, that reports detailed and brief information about multiple different hardware units such as cpu, memory, disk, usb controllers, network adapters etc. Lshw extracts the information from different /proc files.

Do remember that the lshw command executed by root (superuser):

Lets try lshw -short :

### lspci

lspci is a utility for displaying information about PCI buses in the system and devices connected to them.By default, it shows a brief list of devices.

All of lspci switches:

The `-t` option will display the output in tree format with information about bus, and how devices are connected to those buses. The output will be only using the numerical ids:

lspci has a very helpful switch to know the name of the kernel module that will be handling the operations of a particular device. (this option will work only on Kernel 2.6 version and above):

lets try a tool in order to see whether these modules have been loaded.

### lsmod

lsmod is a very simple program with no options.

it nicely formats the contents of the file /proc/modules, which contains information about the status of all currently-loaded Linux Kernel Modules (LKMs).

try `cat /proc/modules` and compare the results.

There is nothing like Drivers in linux and as we said, udev is responsible for calling related module with required information using modprobe.

### modprobe

modprobe intelligently adds or removes a module from the Linux kernel. For demonstration lets remove and add e1000 module which is for Ethernet car on my system:

and we would get disconnected and then connected again. modprobe has a long list of options try`modprobe --help` to see them.

.

.

.

Sources:

<https://www.tldp.org/HOWTO/SCSI-2.4-HOWTO/procfs.html>

<https://medium.com/@jain.sm/pseudo-file-systems-in-linux-5bf67eb6e450>

<https://stackoverflow.com/questions/16431554/how-devfs-and-dev-file-system-differ>

<https://www.tecmint.com/load-and-unload-kernel-modules-in-linux/>

<http://dwaves.de/2017/05/29/linux-difference-between-proc-sys-and-dev-sysfs/>

<https://www.linuxtopia.org/online_books/introduction_to_linux/linux_The_most_common_devices.html>

<https://unix.stackexchange.com/questions/176215/difference-between-dev-and-sys>

<https://wiki.debian.org/udev>

<https://opensource.com/article/16/11/managing-devices-linux>

<https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/s2-sysinfo-hardware-lsusb>

<https://www.systutorials.com/docs/linux/man/8-lspci/>

<https://www.computerhope.com/unix/lsmod.htm>

<https://www.binarytides.com/linux-commands-hardware-info/>

<https://linux.die.net/man/8/modprobe>