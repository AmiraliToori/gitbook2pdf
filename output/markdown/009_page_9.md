Copy

# 103.1. Work on the command line

### **103.1 Work on the command line**

**Weight**: 4

**Description:**Candidates should be able to interact with shells and commands using the command line. The objective assumes the Bash shell.

**Key Knowledge Areas:**

* Use single shell commands and one line command sequences to perform basic tasks on the command line
* Use and modify the shell environment including defining, referencing and exporting environment variables
* Use and edit command history
* Invoke commands inside and outside the defined path

**Terms and Utilities:**

* bash
* echo
* env
* export
* pwd
* set
* unset
* man
* uname
* history
* .bash\_history

**What's A "Terminal?"**

It's a program called a terminal emulator. This is a program that opens a window and lets you interact with the **shell**. There are a bunch of different terminal emulators we can use. Most Linux distributions supply several, such as: gnome-terminal, konsole, xterm, **... ,** It is also called Console.

**What is "The Shell"?**

Simply put, the shell is a program that takes commands from the keyboard and gives them to the operating system to perform. In the old days, it was the only user interface available on a Unix-like system such as Linux. Nowadays, we have graphical user interfaces (GUIs) in addition to command line interfaces (CLIs) such as the shell.

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LqAGZBTzViD1dkOj2A0%252F-LqAGbWkyCRYcuNGU6VA%252Fcommandintro-shell.jpg%3Fgeneration%3D1569999770421965%26alt%3Dmedia&width=768&dpr=4&quality=100&sign=e939fb5d&sv=2)

**What is The "bash"?**

On most Linux systems a program called **bash acts as the shell** program. bash stands for **Bourne Again SHell**, an enhanced version of the original Unix shell program, sh, written by Steve Bourne

Besides, There are other shell programs that can be installed in a Linux system. These include: ksh, tcsh and zsh.

note: Historically the original /bin/sh Bourne shell would use **$** as the normal prompt and **#** for the root user prompt This made it pretty easy to tell if you were running as superuser or not.

**Standard Input, Standard Output and Standard Error**

In general, a command (a program):

* Gets data to process from standard input or **stdin** (default: keyboard).
* Returns processed data to standard output or **stdout** (default: screen).
* If program execution causes errors, error messages are sent to standard error or **stderr** (default: screen).

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LqAGZBTzViD1dkOj2A0%252F-LqAGbWvUfOCFqTekssK%252Fcommandintro-InputOutput.jpg%3Fgeneration%3D1569999770256219%26alt%3Dmedia&width=768&dpr=4&quality=100&sign=4c0ce014&sv=2)

### echo

echo is one of the most commonly and widely used built-in command for Linux bash and C shells, that typically used in scripting language and batch files to display a line of text/string on standard output or a file.

The syntax for echo is: `echo [option(s)] [string(s)]`

example : Input a line of text and display on standard output:

The echo command has a couple of options. Normally, echo will append a trailing new line character to the output. Use the`-n`option to suppress this:

#### Special Characters or Meta Characters

What makes a character special? If it has a meaning beyond its literal meaning, a meta-meaning, then we refer to it as a special character or metacharacters like : `` | & ; ( ) < > [ ] { } * ! ? ` ' " $ \ / # ``

**pound sign (#)**

Everything written after a pound sign (#) is ignored by the shell. This is useful to write a shell comment, but has no influence on the command execution or shell expansion.

**end of line backslash \**

Lines ending in a backslash are continued on the next line. The shell does not interpret the newline character and will wait on shell expansion and execution of the command line until a newline without backslash is encountered.

**escaping special characters**

The backslash character enables the use of control characters, but without the shell interpreting it, this is called **escaping characters**.

**Double quotes " "**

Enclosing characters in double quotes (`"`) preserves the literal value of all characters within the quotes, [*with the exception of* `$`*,* `` ` ``*,* `\`*, and, when history expansion is enabled,* `!`  .*The characters* `$` *and* `` ` `` *retain their special meaning within double quotes*`].`

Lets take a look at other options of echo command:

Use the`-e`option to enable certain backslash **escaped characters** to have special meaning.

Escape sequence

Function

\a

Alert (bell)

\b

Backspace

\c

Suppress trailing newline (same function as -n option)

\f

Form feed (clear the screen on a video display)

\n

New line

\r

Carriage return

\t

Horizontal tab

\v

vertical tab

Some examples:

One of echo command usage is getting variable values with `echo $VARIABLENAME` command. We will see that.

### **Control Operators**

Certain metacharacters or pairs of metacharacters also serve as control operators:`|| && & ; ;; | ()`

Some of these control operators allow you to create sequences or lists of commands.

#### Linux command chaining

Sometimes we would want to run multiple commands in succession or simultaneously. This allows us to automate a process that include several commands that may or may not depend on the result of the previous command.

**Linux command chaining** is the method of combining several different commands such that each of them can execute in succession based on the operator that separate them. The important part of chaining is the operators that we use to combine them. These operators determine how the commands execute.

Lets take a look at some of operators that are used mostly to combine different commands :

**Semi-Colon** (**;**) : The succeeding commands will execute regardless of the exit status of the command that precedes it.

**Logical AND** (**&&**) : This command that follows this operator will execute only if the preceding command executes successfully.

**Logical OR** (**||**) : The command that follows will execute only if the preceding command fails.

## Environment Variables

Environment Variables are some special variables that are defined in shell and are needed by programs while execution. They can be system defined or user defined.

System defined variables are those which are set by system and are used by system level programs.

The whole concept of setting and un-setting environment variables revolves around some set of files and few commands and different shells.

an environment variable can be in three types:

**1. Local Environment Variable** :One defined for the current session. These environment variables last only till the current session, be it remote login session, or local terminal session. These variables are not specified in any configuration files and are created, and removed by using a special set of commands.

**2. User Environment Variable** : These are the variables which are defined for a particular user and are loaded every time a user logs in using a local terminal session or that user is logged in using remote login session. These variables are typically set in and loaded from some configuration files which are present in userâ€™s home directory.

**3. System wide Environment Variables** :These are the environment variables which are available system-wide, i.e. for all the users present on that system. These variables are present in system-wide configuration files present in /etc directories and files.These variables are loaded every time system is powered on and logged in either locally or remotely by any user.

### env

By default, "env" command lists all the current environment variables.

These varibales make working with shell easier. Some of most important ones are:

* **HOSTNAME**:The name of the your computer.
* **SHELL**: This describes the shell that will be interpreting any commands you type in. In most cases, this will be bash by default, but other values can be set if you prefer other options.
* **TERM**: This specifies the type of terminal to emulate when running the shell. Different hardware terminals can be emulated for different operating requirements. We usually won't need to worry about this though.
* **USER**: The current logged in user.
* **LS\_COLORS**: This defines color codes that are used to optionally add colored output to the ls command. This is used to distinguish different file types and provide more info to the user at a glance.
* **MAIL**: The path to the current user's mailbox.
* **PATH**: A list of directories that the system will check when looking for commands. When a user types in a command, the system will check directories in this order for the executable.

> For running other scripts or commands we can add them to path, or use full path or relative path (. and ..)
>
> PATH=$PATH:/tmp/mybin

* **PWD**: The current working directory.

> We use pwd command to see that:

* **LANG**: The current language and localization settings, including character encoding.
* **HOME**: The current user's home directory.
* **\_**: The most recent previously executed command.
* **OLDPWD**: The previous working directory. This is kept by the shell in order to switch back to your previous directory by running cd -.

The exit code of the previous command is stored in the shell variable $?. Actually $? is a shell parameter and not a variable, since you cannot assign a value to $?.

`[root@centos7-1 ~]# touch my.txt`

`[root@centos7-1 ~]# echo $?`

`0`

To see the value of a variable use `echo $VARIABLENAME` :

To set a Local Variable we create a local variable VAR1 and set it to any value( Historically it is recommended to use upper case for variables but you are free to use what ever case you want):

By default variables are local, so What will happen to our Variable if we start a new sub shell ?

It shows nothing. Why?

**Child vs Parent process**

Any process can be a parent and child process at the same time. The only exception is the init process, which is always marked with PID ( process ID ) 1. Therefore, init is a parent of all processes running on your Linux system.

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LqAGZBTzViD1dkOj2A0%252F-LqAGbX5JIK655nKuHdo%252Fcommandintro-parentchild.jpg%3Fgeneration%3D1569999770261843%26alt%3Dmedia&width=768&dpr=4&quality=100&sign=3063ea34&sv=2)

Any process created will normally have a parent process from which it was created and will be considered as a child of this parent process.
`echo $$` print a PID for a current shell

When creating a new child process (a sub shell in our example) an export command simply ensures that any exported variables in the parent process are available in the child process.

We can terminate a shell using the exit command or simply press ctrl+d keys.

**( )** : parentheses really put the command in a subshell. try(exit)

### export

export command is one of the bash shell builtin commands, marks an environment variable to be exported to child-processes, so that the child inherits them.

Syntax:`export [-fn] [name[=value] ...] or export -p`

The export command is fairly simple to use as it has straightforward syntax with only three available command options.

Following our example:

### set

`set`is a shell built-in that (If no options or arguments are supplied) displays all shell variables, not only the environment ones, and also shell functions, which is what you are seeing at the end of the list.

> **set vs env**
>
> Long story short: set can see shell-local variables, env cannot.
>
> As we have mentioned, shells can have variables of 2 types: locals, which are only accessible from the current shell, and (exported) environment variables, which are passed on to every executed program.
>
> Since set is a built-in shell command, it also sees sees shell-local variables (including shell functions). env on the other hand is an independent executable; it only sees the variables that the shell passes to it, or environment variables

In bash like in any Bourne-like shell, set is the command to set options (shell configuration settings like -f, -C, -o noclobber...) and positional parameters ($1, $2...).

Use - and + signs for enabling and disbaling options.Try`help set | less` .

To see the current shell options use `echo $-` :

For example -u treat unset variables as an error when substituting:

We can use `set -o` without any option to get the current state of shell options :

set +o turns off specified option and set -o turns it on .For example lets disable and enable History Storing with -o option:

One of important options you might be asked for in the exam is noclobber, The noclobber option prevents you from overwriting existing files with the > operator (Discussed in next courses).

set is not for setting variables. Do not make mistake!

Set has lots of options which are used to change bash behaviour.

### unset

unset command is used to unset any local environment variable temporarily:

So `set` is not set, but `unset` is unset.

We can also use `env VARNAME=VALUE` and `env -u VARNAME` to set and unset a variable.

## Understanding Bash History

History of all commands which are executed by all users are stored.History is maintained both in ram and in a file*.bash\_history.* History which is maintained in ram, manipulated with the command`history`and environment variables. It is important to note that the history contained in ram is only written after a user logs out of his or her session.

### history

history shows the current content of Bash's history list in memory for the current session.

How many lines are stored in RAM version of History list? It is defined by HISTSIZE variable.

* **HISTSIZE** : This variable contains the maximum number of lines that be contained in the in-ram version of history.

and that would be 1000 lines! to see just 5 lines for example use`history 5` .

**Repeat previous command quickly(3 methods)**

1. Use the **up arrow** to view the previous command and press enter to execute it.
2. **Type !! and press enter** from the command line.(or **!!number** )
3. **Press Control+P** will display the previous command, press enter to execute it

**Search the history(3 methods)**

1. **Control+R:** Press Control+R and type the keyword.
2. **!string** Refers to the most recent command starting with string.
3. **!?string?** Refers to the most recent command containing string (the ending ? is optional).

**Clear all the previous history :** Use history -c option.

### **~/.bash\_history**

When user closes shell , Bash will save its history list to the disk by appending the contained entries to his/her **~/.bash\_history** hidden file. **~/.bash\_history** is controlled by some variables:

* **HISTFILE** This variable contains the location of the history file. When bash is logged out of, the contents of the history command will be written to this file.
* **HISTFILESIZE** The variable contains the maximum number of lines that may be in the history file. When bash writes to the history file, the oldest commands that go over this maximum number will be deleted.

  it acts the same as HISTSIZE.
* **HISTCONTROL** This variable contains instructions for what should be ignored when added to the history file. has four settings:

To see the **.bash\_history** hidden file we should use ls with `-a` switch:

What about other users?

As an instance lets find out what user1 has done:

He/she has done nothing:). **.bash\_history** by default keeps 500 or 1000 of command which has been used.So we can go back to some thing we have done long time ago. history -c does not clear that and it remains after user log off, so if you don't like it you should remove it.

### uname

uname command without any switch will print system information :

Its syntax is like `uname [OPTION] ...` .For example`-a, --all`Prints all information:

If -a (--all) is specified, the information is printed in the following order of individual options:

Processor information (-p) and Hardware-Platform(-i) are omitted if they are unknown.

### man

In Unix-like operating systems, a man page (in full manual page) is a documentation for a terminal-based program/tool/utility (commonly known as a command). It contains:

* **the name of the command**
* **syntax for using it**
* **a description**
* **options available**
* **author**
* **copyright**
* **related commands and ... .**

To read a manual page for a Unix command, a user can type:

For example try `man man` :

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LqAGZBTzViD1dkOj2A0%252F-LqAGbXRj2sEV-XoS0LU%252Fcommandintro-manman.jpg%3Fgeneration%3D1569999770424556%26alt%3Dmedia&width=768&dpr=4&quality=100&sign=654971ec&sv=2)

By default, man typically uses a terminal pager program such as **more** or **less** to display its output.

The manual is generally split into eight or nine numbered sections, organized as follows :

1. **Executable programs or shell commands**
2. **System calls** (functions provided by the kernel)
3. **Library calls** (functions within program libraries)
4. **Special files** (usually found in /dev)
5. **File formats and conventions** eg /etc/passwd
6. **Games**
7. **Miscellaneous** (including macro packages and conventions), e.g. man(7), groff(7)
8. **System administration commands** (usually only for root)
9. **Kernel routines** [Non standard]

To make man display manual page from specific sections use `man [section-num] [command/tool name]` :

man will search for the desired manual pages within the index database caches. So there is no need to remember section numbers for manual entries .

#### mandb

mandb is used to initialise or manually update index database caches
that are usually maintained by man. The caches contain information
relevant to the current state of the manual page system and the
information stored within them is used by the man-db utilities to
enhance their speed and functionality.

the cache consistency check can be slow on systems with many manual pages installed, so mandb is not performed by default, and system administrators may wish to run mandb every week or so to keep the database caches fresh.

**Most useful man command options:**

`-f, --whatis`Display a short description from the manual page

`-w, --where, --location` Don't actually display the manual pages, but do print of the source off files

`-k, --apropos` Equivalent to apropos. Search the short manual page descriptions for keywords and display any matches.

### apropos

apropos command is used to search and display a short man page description of a command/program as follows.

That is all!

.

.

.

sources:

<http://linuxcommand.org/lc3_lts0010.php>

<https://stackoverflow.com/questions/6697753/difference-between-single-and-double-quotes-in-bash>

<https://www.w3resource.com/linux-system-administration/control-operators.php>

<https://www.tecmint.com/set-unset-environment-variables-in-linux/>

<https://unix.stackexchange.com/questions/291729/why-is-the-default-symbol-for-a-user-shell-and-the-default-symbol-for-a-root>

<http://labor-liber.org/en/gnu-linux/introduction/index.php?diapo=input_output>

<http://www.lostsaloon.com/technology/how-to-chain-commands-in-linux-command-line-with-examples/>

<https://www.tecmint.com/chaining-operators-in-linux-with-practical-examples/>

<https://www.tecmint.com/echo-command-in-linux/>

[https://developer.ibm.com/tutorials/l-lpic1-103-1/](https://legacy.gitbook.com/book/borosan/lpic1-exam-guide/edit#)

<https://ss64.com/bash/syntax-quoting.html>

<https://linuxconfig.org/learning-linux-commands-export>

<https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-a-linux-vps>

<http://www.symkat.com/understanding-bash-history>

<https://www.tecmint.com/history-command-examples/>

<https://www.thegeekstuff.com/2008/08/15-examples-to-master-linux-command-line-history>

<https://www.computerhope.com/unix/uuname.htm>

<https://en.wikipedia.org/wiki/Man_page>

<https://www.tecmint.com/view-colored-man-pages-in-linux/>

<https://www.techonthenet.com/linux/commands/man.php>

<http://man7.org/linux/man-pages/man8/mandb.8.html>

<https://bash.cyberciti.biz/guide/Shopt>

.