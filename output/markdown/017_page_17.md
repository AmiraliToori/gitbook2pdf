Copy

# 104.1. Create partitions and filesystems

## **104.1 Create partitions and filesystems**

**Weight:** 2

**Description:** Candidates should be able to configure disk partitions and then create filesystems on media such as hard disks. This includes the handling of swap partitions.

**Key Knowledge Areas:**

* Manage MBR partition tables
* Use various mkfs commands to create various filesystems such as:
* ext2/ext3/ext4
* XFS
* VFAT
* Awareness of ReiserFS and Btrfs
* Basic knowledge of gdisk and parted with GPT

**Terms and Utilities:**

* fdisk
* gdisk
* parted
* mkfs
* mkswap

### BIOS

The Basic Input/Output System (BIOS), (also known as System BIOS, ROM BIOS ) is a standard for defining a firmware interface. The BIOS software is built into the PC, and is the first software run by a PC when powered on.

The fundamental purposes of the BIOS are to initialize and test the system hardware components, and to load a bootloader or an operating system from a mass memory device.

### UEFI

The Unified Extensible Firmware Interface (UEFI) is a specification that defines a software interface between an operating system and platform firmware. UEFI is meant to replace the Basic Input/Output System (BIOS) firmware interface. In practice, most UEFI images provide legacy support for BIOS services. UEFI can support remote diagnostics and repair of computers, even without another operating system!

> The original EFI (Extensible Firmware Interface) specification was developed by Intel. UEFI is still not widespread and major hardware companies have switched over almost exclusively to UEFI use. Many older and less expensive motherboards also still use the BIOS system.

### MBR

A master boot record (MBR) is a special type of boot sector at the very beginning of partitioned computer mass storage devices like fixed disks or removable drives.

The MBR holds the information on how the logical partitions, containing file systems, are organized on that medium. Besides that, the MBR also contains executable code to function as a loader for the installed operating system—usually by passing control over to the loader's second stage. This MBR code is usually referred to as a boot loader.

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LqAGZBTzViD1dkOj2A0%252F-LqAGbXFUGnPdIROQR2n%252Fbootloader-mbr.jpg%3Fgeneration%3D1569999728181812%26alt%3Dmedia&width=768&dpr=4&quality=100&sign=4996336a&sv=2)

**Master Boot records has some short comings:**

* MBR puts all information in first sector of hard disk so if any problem ocures for that sectore, system won't be able to boot up.
* MBR contains only four entries (slots) for four Primary partitions, one of which can be an Extended partition. This partition will contain unallocated space within it where we can create unlimited number of Logical partitions.

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LxXp8KPLaqG3N8egRdZ%252F-LxXq3KoSH2RwxmR2cOY%252Fcreatepartition-mbrpart.jpg%3Falt%3Dmedia%26token%3D77188eb6-4fbc-44ce-a3d2-fd488fb8d0b7&width=768&dpr=4&quality=100&sign=aa7f31c&sv=2)

* The organization of the partition table in the MBR limits the maximum addressable storage space of a disk to 2 TB.

Therefore, the MBR-based partitioning scheme is in the process of being superseded by the GUID Partition Table (GPT) scheme in new computers. A GPT can coexist with an MBR in order to provide some limited form of a backwards compatibility for older systems.

### GPT

GUID Partition Table (GPT) is a standard for the layout of the partition table on a physical hard disk, using globally unique identifiers (GUID).

Although it forms a part of the Unified Extensible Firmware Interface (UEFI) standard, it is also used on some BIOS systems because of the limitations of master boot record (MBR) partition tables.

### MBR vs GBT

MBR(Master Boot Record)

GPT(GUID Partition Table)

Since 1983

New 2005-...

lives on first sector

Stored in multiple locations on Drive

Limited to 4 partitions per disk

Limited to 2 TB partitions

Supports 128 partitions per disk

Supports 18EX partition

> Both GPT disk and MBR disk can be basic or dynamic.

### BIOS vs UEFI

BIOS(Basic Input/Output System)

UEFI(Unified Extensible Frimware Interface)

Only Supports MBR( So GPT itself acts like MBR!)

Native GPT support

Sees GPT as a drive with a single MBR partition

Usually need to run in legacy mode ti support MBR

Usually, MBR and BIOS **(MBR + BIOS)**, and GPT and UEFI **(GPT + UEFI)** go hand in hand. This is required for some systems (Windows), while optional for others (Linux).

### Block devices

A block device is an abstraction layer for any storage device that can be formatted in fixed-size blocks and blocks should be able to be access randomly.

Examples of block devices include the first IDE or SATA hard drive on our system (/dev/sda or /dev/hda) or the second SCSI, IDE, or USB drive (/dev/sdb). Use the `ls -l` command to display /dev entries.

The first character on each output line is **b** for a **block** device, such as floppy, CD drive, IDE hard drive, or SCSI hard drive; and **c** for a **character** device, such as a or terminal (tty) or the null device.

#### Disk Partitioning

Now that we are introduced you to hard drive layouts (MBR & GPT) , lets learn how to create MBR partitions using fdisk and GPT partitions using gdisk.

### fdisk

**fdisk** also known as format disk is a dialog-driven command in Linux used for creating and manipulating disk partition table. It is used for the view, create, delete, change, resize, copy and move partitions on a hard drive using the dialog-driven interface.
fdisk allows us to create a maximum of four primary partitions and the number of logical partition depends on the size of the hard disk you are using. It allows the user:

* To Create space for new partitions.
* Organizing space for new drives.
* Re-organizing old drives.
* Copying or Moving data to new disks(partitions)

The first thing to do before doing any thing with the disks and partition is to view basic details about all available partition in the system using `-l` option(ubuntu 16.04):

as you can see we have two disk drives (sda,sdb) sda has some partitions on it but sdb is row.

* **Boot** : The Boot column shows that the first partition, /dev/sda1, has an asterisk **(\*)** indicating that this partition contains the files required by the boot loader to boot the system.
* **Start and End** : The start and end columns list the starting and ending sectors of each partition.
* **Blocks** : The blocks column lists the number of blocks allocated to the partition.
* **Id and System** : These columns identify the partition type.

Viewing Partition(s) on a Specific Disk (sda) :

Lets start interactive mode and see all available commands (sdb):

okey creating partion:

next we need to specify partition type based on the future use we have considered for:

**Partition Types**

The partition types can be displayed and changed by using the fdisk utility. A partial list (most commonly used) of partition types are:
**83: Linux
82: Linux swap
5: Extended
8e: Linux LVM**

and use -p option inorder to print partition table:

fdisk does not write any changes on hard disk until we ask it using `w` switch, if you are not sure use `q` to quit and hard disk stays untouched!

use -d for delete a partition bu be care full!

> To see the help message and listing of all options, use fdisk -h command.

### gdisk

We can Manage GPT Partitions with gdisk. like fdisk, gdisk is a text-mode menu-driven program for creation and manipulation of partition tables. It will automatically convert an old-style Master Boot Record (MBR) partition table to the newer Globally Unique Identifier (GUID) Partition Table (GPT) format, or will load a GUID partition table.

### parted

The `parted` command is a partition editor that will work with both MBR and GPT formatted disks.

### File System

Linux File System or any file system generally is a layer which is under the operating system that handles the positioning of your data on the storage, without it; the system cannot knows which file starts from where and ends where.

### **File system types**

Linux supports several different file systems. Each has strengths and weaknesses and its own set of performance characteristics.

**Ext, Ext2, Ext3, Ext4, JFS, XFS, btrfs and swap**

One important attribute of a filesystem is journaling

**What is journaling?**

Journaling is designed to prevent data corruption from crashes and sudden power loss. Let’s say your system is partway through writing a file to the disk and it suddenly loses power. Without a journal, your computer would have no idea if the file was completely written to disk. The file would remain there on disk, corrupt.

![](https://borosan.gitbook.io/lpic1-exam-guide/~gitbook/image?url=https%3A%2F%2F588171885-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-LqAGY8muYlSuaVSKvqr%252F-LxR7luULR8_XmJ7NnPH%252F-LxRDcMVNK4jB3zXLUCQ%252Fcreatepartition-journaling.jpg%3Falt%3Dmedia%26token%3Dbf5b6b55-ca03-459c-a45a-d3a50e46dfaf&width=768&dpr=4&quality=100&sign=dc88699a&sv=2)

With a journal, your computer would note that it was going to write a certain file to disk in the journal, write that file to disk, and then remove that job from the journal. If the power went out partway through writing the file, Linux would check the file system’s journal when it boots up and resume any partially completed jobs. This prevents data loss and file corruption.

Journaling does slow disk write performance down a tiny bit, but it’s well-worth it on a desktop or laptop.

Which File System is perfect for you?

Generally, a journaling filesystem is preferred over a non-journaling one when you have a choice. You may also want to consider whether your chosen filesystem supports *Security Enhanced Linux* (or SELinux).

Following is a brief summary of the types you need to know about for the LPI exam**:**

Format

Description

**ext2**

(1993)

The ext2 filesystem (also known as the *second extended filesystem*) was developed to address shortcomings in the Minix filesystem used in early versions of Linux. It has been used extensively on Linux for many years. There is no journaling in ext2, and it has largely been replaced by ext3 and more recently ext4.

1. Maximum file size is **16GB – 2TB**.

\*It’s being used for normally Flash based storage media like **USB Flash drive**, **SD Card** etc.

**ext3**

(2001)

The ext3 filesystem adds journaling capability to a standard ext2 filesystem and is therefore an evolutionary growth of a very stable filesystem. It offers reasonable performance under most conditions and is still being improved. Because it adds journaling on top of the proven ext2 filesystem, it is possible to convert an existing ext2 filesystem to ext3 and even convert back again if required.

1. Max file size **16GB – 2TB**.
2. was integrated in **Kernel 2.4.15** with journaling feature

**ext4**

(2008)

The ext4 filesystem started as extensions to ext3 to address the demands of ever larger file systems by increasing storage limits and improving performance. Some of the changes from ext3 are:

1. Max file size **16GB to 16TB**.
2. was included in the **2.6.28 kernel**.
3. Ext4 file system have option to **Turn Off** journaling feature.
4. Other features like **Fast FSCK** etc.

**ReiserFS**

ReiserFS is a B-tree-based filesystem that has very good overall performance, particularly for large numbers of small files. has journaling. no longer in active development, does not support SELinux and has largely been superseded by Reiser4 whose future is unclear.

**XFS**

XFS is a filesystem with journaling. It comes with robust features and is optimized for scalability. XFS aggressively caches in-transit data in RAM, great if you have an uninterruptible power supply.

**btrfs**

btrfs (B-Tree file system) was initially developed by Oracle(GPL).It is a new copy-on-write filesystem for Linux aimed at implementing advanced features(snapshots,compression,...) while focusing on fault tolerance, repair, and easy administration.Designed to handle large files efficiently and handle filesystems spread across multiple devices.

**vfat**

(also known as *FAT32*) no journaling, lacks many features required for a full Linux filesystem implementation. useful for exchanging data between Windows and Linux systems . Do **not** use this filesystem , except for sharing data .

\*If you unzip or untar a Linux archive on a vfat disk, you will lose permissions, such as execute permission, and you will lose any symbolic links that may have been stored in the archive.

**swap**

Swap space must be formatted for use as swap space, but it is not generally considered a filesystem.

We must create a file system before you can use any data storage device connected to a Linux computer.

### partitioning

Linux uses the `mkfs` command to create filesystems and `mkswap`command to make swap space.

Before you start modifying partitions, there are some important things to remember. You risk losing your existing data if you do not follow these guidelines:

1. Back up important data before you start
2. Do not change partitions that are in use
3. Know your tool
4. Stop if you do make a mistake

Linux uses the `mkfs` command to create filesystems and `mkswap`command to make swap space

### mkfs

The mkfs (make filesystem) command is used to create a filesystem.

The `mkfs` command is actually a front end to several filesystem-specific commands such as `mkfs.ext3` for ext3, `mkfs.ext4` for ext4 and `mkfs.btrfs` for btrfs.

various forms of some commands. mke2fs, mkfs.ext2, and mkfs.ext3 are all the same file, while mkfs.msdos and mkfs.vfat are usually symbolic links to mkdosfs.

In order to build the filesystem using mkfs command, the required arguments are filesystem-type and device-filename:

We can either use mkfs.*fstype* commands `mkfs.ext3 /dev/sdb1`  or we can use mkfs via `-t` option to specify the format `mkfs -t ext3 /dev/sdb1` and both would have the same results.

If we want to assign a label to the partition during format progress we should use -L labelname with that : `mkfs -t ext3 -L MyData /dev/sdb1`

For mounting Formatted partition we can either use Partition label or **UUID**. **UUID** *is a unique identifier used in partitions to uniquely identify partitions*. to get the UUID of recent created partition try : `blkid /dev/sdb1`

Partition

Format Type

Sample Command

Notes

/dev/sdb1

ext4

mkfs -t ext4 -L data /dev/sdb1

Assigns Label,same as mkfs.ext4

/dev/sdb2

xfs

mkfs -t xfs -i size=512 /dev/sdb2

telling it to have larger inodes (normal is 256) it helps Selinux

/dev/sdc1

ReiserFS

mkfs -t reiserfs /dev/sdc1

Or you can use `mkreiserfs` command.

/dev/sdc2

vFAT

mkfs -t vfat /dev/sdc2

Or you can use `mkfs.vfat` command

/dev/sdc3

Btrfs

mkfs -t btrfs /dev/sdc3

Or you can use `mkfs.btrfs` command

### mkswap

`mkswap`command makes swap space on a device or in a file.

The device argument will usually be a disk partition (something like /dev/sdb1) but can also be a file.

The Linux kernel does not look at partition IDs, but many installation scripts will assume that partitions of hex type 82 (LINUX\_SWAP) are meant to be swap partitions.

So in order to make a swap space first create a partition using fdisk via partition type 82 and then use mkswap:

Using the created partition as a swap space requires further step which will be discussed in later lessons.

that's all!

.

.

.

<https://wiki.manjaro.org/index.php?title=Some_basics_of_MBR_v/s_GPT_and_BIOS_v/s_UEFI>

<https://developer.ibm.com/tutorials/l-lpic1-104-1/>

<https://www.geeksforgeeks.org/file-systems-in-operating-system/>

<https://likegeeks.com/linux-file-system/>

<https://developer.ibm.com/tutorials/l-lpic1-102-1/>

<https://www.computerhope.com/jargon/p/partition.htm>

<https://www.geeksforgeeks.org/fdisk-command-in-linux-with-examples/>

<https://www.tecmint.com/what-is-ext2-ext3-ext4-and-how-to-create-and-convert-linux-file-systems/>

<https://www.howtogeek.com/howto/33552/htg-explains-which-linux-file-system-should-you-choose/>

<https://developer.ibm.com/tutorials/l-lpic1-104-1/>

<https://jadi.gitbooks.io/lpic1/content/1041_create_partitions_and_filesystems.html>

.